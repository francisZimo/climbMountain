<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>标题</title>
    <meta name="keywords" content="">
    <meta name="description" content="">
</head>
<body>
    
</body>
<script>
    // instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型

    // 父类
    function Animal (name) {
        this.name=name||'Animal';
        this.sleep=function  () {
            console.log(this.name+'正在睡觉');
        }
    }
    Animal.prototype.eat = function(food) {
        console.log(this.name+'正在吃:'+food);
    };

    /*// 原型链继承:将父类作为子类的原型
    function Cat () {
        
    }
    Cat.prototype=new Animal();
    Cat.prototype.name='cat';

    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.eat('fish'));
    console.log(cat.sleep());
    console.log(cat instanceof Animal); //true 
    console.log(cat instanceof Cat); //true*/

    /*// 构造继承
    function Cat (name) {
        Animal.call(this);
        this.name=name||'Tom';
    }
    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.eat('fish'));//报错无法继承Animal的原型
    console.log(cat.sleep());
    console.log(cat instanceof Animal); // false
    console.log(cat instanceof Cat); // true*/

    /*// 实例继承：为父类实例添加新特性，作为子类实例返回
    function Cat(name){
      var instance = new Animal();
      instance.name = name || 'Tom';
      return instance;
    }
    // Test Code
    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.eat('fish'));
    console.log(cat.sleep());
    console.log(cat instanceof Animal); // true
    console.log(cat instanceof Cat); // false//不在是子类Cat的实例*/

    /*// 4、拷贝继承：无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）
    function Cat(name){
      var animal = new Animal();
      for(var p in animal){
        Cat.prototype[p] = animal[p];
      }
      Cat.prototype.name = name || 'Tom';
    }
    // Test Code
    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.eat('fish'));
    console.log(cat.sleep());
    console.log(cat instanceof Animal); // false
    console.log(cat instanceof Cat); // true*/

    /*function Cat(name){
      Animal.call(this);
      this.name = name || 'Tom';
    }
    for(var i in Animal.prototype){
        Cat.prototype[i]=Animal.prototype[i]
    }
    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.sleep());
    console.log(cat.eat('fish'));
    console.log(cat instanceof Animal); // false
    console.log(cat instanceof Cat); // true*/
</script>
</html>